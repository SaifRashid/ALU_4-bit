module ALU_1_bit(a,b,binvert,Cin,less,x,y,z,Cout,result);
    input a,b,binvert,Cin,less,x,y,z;
    output Cout,result;
    
    wire b1,o0,o1,o2;
    
    and g0(o0,a,b);
    
    or g1(o1,a,b);
    
    xor g2(b1,b,binvert);

    full_adder FA(a,b1,Cin,o2,Cout);
    
    mux_8x1 OPMUX(o0,o1,o2,1'b0,1'b0,1'b0,o2,less,x,y,z,result);
    
endmodule

module ALU_1_bit_set_overflow(a,b,binvert,Cin,less,x,y,z,set,overflow,result);
    input a,b,binvert,Cin,less,x,y,z;
    output set,overflow,result;
    
    wire b1,o0,o1,o2,v;
    
    and g0(o0,a,b);
    
    or g1(o1,a,b);
    
    xor g2(b1,b,binvert);

    full_adder FA(a,b1,Cin,o2,Cout);
    
    mux_8x1 OPMUX(o0,o1,o2,1'b0,1'b0,1'b0,o2,less,x,y,z,result);
    
    and g3(set, o2);
    
    xor g4(v,Cin,Cout);
    
    and g5(overflow,v,y);
    
endmodule

module ALU_4_bit(op,a,b,result,zero,overflow);
    input [2:0] op;
    input [3:0] a;
    input [3:0] b;
    output [3:0] result;
    output zero,overflow;
    
    wire binvert,set;
    wire [2:0] Cout;
    
    and g0(binvert,op[2],op[1]);
    
    ALU_1_bit ALU0(a[0],b[0],binvert,binvert,set,op[2],op[1],op[0],Cout[0],result[0]);
    ALU_1_bit ALU1(a[1],b[1],binvert,Cout[0],1'b0,op[2],op[1],op[0],Cout[1],result[1]);
    ALU_1_bit ALU2(a[2],b[2],binvert,Cout[1],1'b0,op[2],op[1],op[0],Cout[2],result[2]);

    ALU_1_bit_set_overflow ALU3(a[3],b[3],binvert,Cout[2],1'b0,op[2],op[1],op[0],set,overflow,result[3]);
    
    nor g1(zero,result[0],result[1],result[2],result[3]);
    
endmodule

// Test Module 
module testALU;
  reg signed [3:0] a;
  reg signed [3:0] b;
  reg [2:0] op;
  wire signed [3:0] result;
  wire zero,overflow;
  ALU_4_bit ALU(op,a,b,result,zero,overflow);
  initial
    begin
     $display("op   a        b        result   zero overflow");
     $monitor ("%b %b(%d) %b(%d) %b(%d) %b    %b",op,a,a,b,b,result,result,zero,overflow);
	       op = 3'b000; a = 4'b0111; b = 4'b0010;  // AND
            #1 op = 3'b001; a = 4'b0101; b = 4'b0010;  // OR
            #1 op = 3'b010; a = 4'b0101; b = 4'b0001;  // ADD
	    #1 op = 3'b010; a = 4'b0111; b = 4'b0001;  // ADD overflow (8+1=-8)
	    #1 op = 3'b110; a = 4'b0101; b = 4'b0001;  // SUB
	    #1 op = 3'b110; a = 4'b1111; b = 4'b0001;  // SUB
	    #1 op = 3'b110; a = 4'b1111; b = 4'b1000;  // SUB no overflow (-1-(-8)=7)
	    #1 op = 3'b110; a = 4'b1110; b = 4'b0111;  // SUB overflow (-2-7=7)
	    #1 op = 3'b111; a = 4'b0101; b = 4'b0001;  // SLT
	    #1 op = 3'b111; a = 4'b0001; b = 4'b0011;  // SLT
	    #1 op = 3'b111; a = 4'b1101; b = 4'b0110;  // SLT overflow (-3-6=7 => SLT=0)
    end
endmodule

module half_adder(x,y,S,C);
    input x,y;
    output S,C;
         
    xor g1(S,x,y);
    
    and g2(C,x,y);
endmodule

module full_adder(x,y,z,S,C);
    input x,y,z;
    output S,C;
    wire S1,C1,C2;
    
    half_adder HA1(x,y,S1,C1);
    half_adder HA2(S1,z,S,C2);
    
    or g1(C,C1,C2);
endmodule

module mux_2x1(x,y,z,out);
    input x,y,z;
    output out;
    
    wire a,b;
    
    not notz(notz, z);
    
    and g1(a,x,notz),
        g2(b,y,z);
    
    or  g3(out,a,b);
endmodule

module mux_4x1(I0,I1,I2,I3,S1,S0,out);
    input I0,I1,I2,I3,S1,S0;
    output out;
    
    wire o1, o2;
    
    mux_2x1 MUX1(I0,I1,S0,o1);
    mux_2x1 MUX2(I2,I3,S0,o2);
    mux_2x1 MUX3(o1,o2,S1,out);
endmodule

module mux_8x1(I0,I1,I2,I3,I4,I5,I6,I7,S2,S1,S0,out);
    input I0,I1,I2,I3,I4,I5,I6,I7,S2,S1,S0;
    output out;
    
    wire o1,o2;
    
    mux_4x1 M1(I0,I1,I2,I3,S1,S0,o1);
    mux_4x1 M2(I4,I5,I6,I7,S1,S0,o2);
    mux_2x1 M3(o1,o2,S2,out);

endmodule
